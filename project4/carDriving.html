<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Transformation</title>

    <script id="vertex-shader" type="x-shader/x-vertex">#version 300 es
precision mediump float;
precision lowp int;
in vec4 vPosition;
in vec4 vAmbientDiffuseColor;
in vec4 vNormal;
in vec4 vSpecularColor;
in float vSpecularExponent;

out vec4 color;
out vec4 position;
out vec4 ambientDiffuseColor;
out vec4 normal;
out vec4 specularColor;
out float specularExponent;

uniform mat4 model_view;
uniform mat4 projection;
uniform int mode; //0: unlit, 1:Gouraud, 2: Phong, 3: Cel
uniform vec4 light_position;
uniform vec4 light_color;
uniform vec4 ambient_light;

uniform vec4 headlight_position;
uniform vec4 headlight_direction;
uniform vec4 headlight_color;
uniform float headlight_cutoff;
uniform float headlight_exponent;

void
main()
{
	gl_Position = vec4(0, 0, 0, 1); //to make the shader compiler happy
	if(mode == 0){ //unlit
		color = vAmbientDiffuseColor;
		gl_Position = projection * model_view * vPosition;

	}else if (mode == 1){ // ambient only
        gl_Position = projection * model_view * vPosition;

        vec4 veyepos = model_view * position;
        vec3 L = normalize(light_position.xyz - veyepos.xyz);
        vec3 N = normalize((model_view * vNormal).xyz);

        // compute ambient term
        vec4 amb = vAmbientDiffuseColor * ambient_light;
        vec4 diff = max(dot(L, N), 0.0) * vAmbientDiffuseColor * light_color;

        color = amb + diff;
	}else if (mode == 2){
        position = vPosition;
        ambientDiffuseColor = vAmbientDiffuseColor;
        normal = vNormal;
        specularColor = vSpecularColor;
        specularExponent = vSpecularExponent;


        gl_Position = projection * model_view * vPosition;
	}
}

    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">#version 300 es
precision mediump float;
precision lowp int;

in vec4 color;
in vec4 position;
in vec4 ambientDiffuseColor;
in vec4 normal;
in vec4 specularColor;
in float specularExponent;


uniform mat4 model_view;
uniform mat4 projection;
uniform int mode; //0: unlit, 1:Gouraud, 2: Phong, 3: Cel
uniform vec4 light_position;
uniform vec4 light_color;
uniform vec4 ambient_light;

uniform vec4 headlight_position;
uniform vec4 headlight_direction;
uniform vec4 headlight_color;
uniform float headlight_cutoff;
uniform float headlight_exponent;

out vec4  fColor;

void main()
{
	vec4 amb = vec4(0,0,0,1);
	vec4 diff = vec4(0,0,0,1);
	vec4 spec = vec4(0,0,0,1);

	if(mode == 0){ //Unlit
		fColor = color;

	}else if(mode == 1){ //Gouraud
		fColor = color;
	}else if(mode == 2){
	    vec4 veyepos = model_view * position;
        vec3 L = normalize(light_position.xyz - veyepos.xyz);
        vec3 V = normalize(-veyepos.xyz);
        vec3 N = normalize((model_view * normal).xyz);
        vec3 R = reflect(-L, N); //vector from light source, reflected across normal

        amb = ambientDiffuseColor * ambient_light;
        diff = max(dot(L, N), 0.0) * ambientDiffuseColor * light_color;
        spec = pow(max(dot(R, V), 0.0), specularExponent) * specularColor * light_color;

        if (dot(L, N) < 0.0){
            spec = vec4(0,0,0,1); //no glare beyond the horizon
        }

        vec3 F = veyepos.xyz;  // fragment position in eye space
        vec3 S = headlight_position.xyz;  // headlight position (we'll send it in eye space from TypeScript)
        vec3 lightDirection = normalize(headlight_direction.xyz);  // direction (also in eye space)

        if (dot(lightDirection, normalize(S - F)) >= headlight_cutoff) {
            float spotEffect = pow(dot(lightDirection, normalize(S - F)), headlight_exponent);

            vec3 spotL = normalize(S - F);
            vec4 spotDiff = ambientDiffuseColor * headlight_color * spotEffect;

            vec3 spotR = reflect(-spotL, N);
            vec4 spotSpec = pow(max(dot(spotR, V), 0.0), headlight_exponent) * specularColor * headlight_color * spotEffect;

            if (dot(spotL, N) < 0.0){
                spotSpec = vec4(0,0,0,1);
            }

            diff += spotDiff;
            spec += spotSpec;
        }

        fColor = amb + diff + spec;
	}


}

    </script>

    <script type="module" src="carDriving.js "></script>
</head>
<body>
<div>Practicing transformation matrices</div>
<canvas id="gl-canvas" width="512" height="512">
    Sorry; your web browser doesn't support HTML5's canvas element.
</canvas>
</body>
</html>